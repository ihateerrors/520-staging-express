

<script>

document.addEventListener('DOMContentLoaded', function() {
    const editButtons = document.querySelectorAll('.edit-btn');
    const deleteButtons = document.querySelectorAll('.delete-btn');

    editButtons.forEach(editBtn => {
        editBtn.addEventListener('click', function() {
            const accordionItem = this.closest('.accordion-item');
            const inputs = accordionItem.querySelectorAll('input');
            const id = this.getAttribute('data-id');
            
            // Toggle the input fields' disabled state
            inputs.forEach(input => input.disabled = !input.disabled);

            // Toggle button text between 'Edit' and 'Save'
            if (this.innerText === 'Edit') {
                this.innerText = 'Save';
            } else {
                // Save logic
                const updatedData = {};
                inputs.forEach(input => {
                    updatedData[input.name] = input.value;
                });

                fetch(`/closure/${id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatedData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        console.error('Error:', data.error);
                        alert('There was an error updating the closure.');
                    } else {
                        alert('Closure updated successfully!');
                        this.innerText = 'Edit';
                    }
                })
                .catch(err => {
                    console.error('Fetch error:', err);
                    alert('There was an error updating the closure.');
                });
            }
        });
    });

    deleteButtons.forEach(deleteBtn => {
        deleteBtn.addEventListener('click', async function() {
            const accordionItem = this.closest('.accordion-item');
            const id = this.getAttribute('data-id');

            if (confirm('Are you sure you want to delete this closure?')) {
                try {
                    const response = await fetch(`/closure/${id}`, {
                        method: 'DELETE'
                    });

                    if (response.ok) {
                        // Remove the closure's DOM element
                        accordionItem.remove();
                        alert('Closure deleted successfully!');
                    } else {
                        const data = await response.json();
                        alert('Error deleting closure: ' + data.error);
                    }
                } catch (err) {
                    console.error('Error deleting closure:', err);
                    alert('There was an error deleting the closure.');
                }
            }
        });
    });
});


</script>




<!-- 
// const express=require("express"),router=express.Router(),multer=require("multer"),Closure=require("../models/Project"),storage=multer.diskStorage({destination:function(e,r,t){t(null,"uploads/")},filename:function(e,r,t){t(null,Date.now()+"-"+r.originalname)}}),upload=multer({storage:storage});router.use(upload.single("image")),router.put("/:id",(async(e,r)=>{try{const t=await Closure.findById(e.params.id);if(!t)return r.status(404).json({error:"Closure not found"});if(Object.keys(e.body).forEach((r=>{e.body[r]&&void 0!==t[r]&&(t[r]=e.body[r])})),["startDate","endDate","postDate","removeDate","createdAt","updatedAt"].forEach((r=>{e.body[r]&&(t[r]=new Date(e.body[r]))})),e.file){const r=await uploadToAzure(e.file.buffer,e.file.originalname);t.imageUrl=r}["timingFeatures","activityType","impactType"].forEach((r=>{e.body[r]&&"string"==typeof e.body[r]&&(t[r]=e.body[r].split(",").map((e=>e.trim())))})),e.body.mapData&&(t.mapData=JSON.parse(e.body.mapData)),await t.save(),r.json(t)}catch(e){r.status(500).json({error:"Internal server error while updating closure."})}})),router.delete("/:id",(async(e,r)=>{try{const t=await Closure.findByIdAndDelete(e.params.id);if(!t)return r.status(404).json({error:"Closure not found"});r.json(t)}catch(e){r.status(500).json({error:"Internal server error while deleting closure."})}})),module.exports=router; -->